---name: gsd:plan-phasedescription: Create detailed execution plan for a phase (PLAN.md) with verification loopargument-hint: "[phase] [--research] [--skip-research] [--gaps] [--skip-verify]"agent: gsd-plannerallowed-tools:  - Read  - Write  - Bash  - Glob  - Grep  - Task  - WebFetch  - mcp__context7__*---<execution_context>@./.claude/get-shit-done/references/ui-brand.md</execution_context><objective>Create executable phase prompts (PLAN.md files) for a roadmap phase with integrated research and verification.**Default flow:** Research (if needed) → Plan → Verify → Done**Orchestrator role:** Parse arguments, validate phase, research domain (unless skipped or exists), spawn gsd-planner agent, verify plans with gsd-plan-checker, iterate until plans pass or max iterations reached, present results.**Why subagents:** Research and planning burn context fast. Verification uses fresh context. User sees the flow between agents in main context.</objective><context>Phase number: $ARGUMENTS (optional - auto-detects next unplanned phase if not provided)**Flags:**- `--research` — Force re-research even if RESEARCH.md exists- `--skip-research` — Skip research entirely, go straight to planning- `--gaps` — Gap closure mode (reads VERIFICATION.md, skips research)- `--skip-verify` — Skip planner → checker verification loopNormalize phase input in step 2 before any directory lookups.</context><process>## 1. Validate Environment and Resolve Model Profile```bashls .planning/ 2>/dev/null```text```bashMODEL_PROFILE=$(cat .planning/config.json 2>/dev/null | grep -o '"model_profile"[[:space:]]*:[[:space:]]*"[^"]*"' | grep -o '"[^"]*"$' | tr -d '"' || echo "balanced")```text```bash# Normalize phase number (8 → 08, but preserve decimals like 2.1 → 02.1)if [[ "$PHASE" =~ ^[0-9]+$ ]]; then  PHASE=$(printf "%02d" "$PHASE")elif [[ "$PHASE" =~ ^([0-9]+)\.([0-9]+)$ ]]; then  PHASE=$(printf "%02d.%s" "${BASH_REMATCH[1]}" "${BASH_REMATCH[2]}")fi```text```bashls .planning/phases/${PHASE}-*/*-RESEARCH.md 2>/dev/nullls .planning/phases/${PHASE}-*/*-PLAN.md 2>/dev/null```css```bashgrep -A5 "Phase ${PHASE}:" .planning/ROADMAP.md 2>/dev/null```csv```bash# PHASE is already normalized (08, 02.1, etc.) from step 2PHASE_DIR=$(ls -d .planning/phases/${PHASE}-* 2>/dev/null | head -1)if [ -z "$PHASE_DIR" ]; then  # Create phase directory from roadmap name  PHASE_NAME=$(grep "Phase ${PHASE}:" .planning/ROADMAP.md | sed 's/.*Phase [0-9]*: //' | tr '[:upper:]' '[:lower:]' | tr ' ' '-')  mkdir -p ".planning/phases/${PHASE}-${PHASE_NAME}"  PHASE_DIR=".planning/phases/${PHASE}-${PHASE_NAME}"fi```css```bashWORKFLOW_RESEARCH=$(cat .planning/config.json 2>/dev/null | grep -o '"research"[[:space:]]*:[[:space:]]*[^,}]*' | grep -o 'true\|false' || echo "true")```text```bashls "${PHASE_DIR}"/*-RESEARCH.md 2>/dev/null```css```text
```css```bash# Get phase description from roadmapPHASE_DESC=$(grep -A3 "Phase ${PHASE}:" .planning/ROADMAP.md)# Get requirements if they existREQUIREMENTS=$(cat .planning/REQUIREMENTS.md 2>/dev/null | grep -A100 "## Requirements" | head -50)# Get prior decisions from STATE.mdDECISIONS=$(grep -A20 "### Decisions Made" .planning/STATE.md 2>/dev/null)# Get phase context if existsPHASE_CONTEXT=$(cat "${PHASE_DIR}/${PHASE}-CONTEXT.md" 2>/dev/null)```text```markdown<objective>Research how to implement Phase {phase_number}: {phase_name}Answer: "What do I need to know to PLAN this phase well?"</objective><context>**Phase description:**{phase_description}**Requirements (if any):**{requirements}**Prior decisions:**{decisions}**Phase context (if any):**{phase_context}</context><output>Write research findings to: {phase_dir}/{phase}-RESEARCH.md</output>```text```csv
```css```bashls "${PHASE_DIR}"/*-PLAN.md 2>/dev/null```csv```bash# Read required filesSTATE_CONTENT=$(cat .planning/STATE.md)ROADMAP_CONTENT=$(cat .planning/ROADMAP.md)# Read optional files (empty string if missing)REQUIREMENTS_CONTENT=$(cat .planning/REQUIREMENTS.md 2>/dev/null)CONTEXT_CONTENT=$(cat "${PHASE_DIR}"/*-CONTEXT.md 2>/dev/null)RESEARCH_CONTENT=$(cat "${PHASE_DIR}"/*-RESEARCH.md 2>/dev/null)# Gap closure files (only if --gaps mode)VERIFICATION_CONTENT=$(cat "${PHASE_DIR}"/*-VERIFICATION.md 2>/dev/null)UAT_CONTENT=$(cat "${PHASE_DIR}"/*-UAT.md 2>/dev/null)```css```text
```text```markdown<planning_context>**Phase:** {phase_number}**Mode:** {standard | gap_closure}**Project State:**{state_content}**Roadmap:**{roadmap_content}**Requirements (if exists):**{requirements_content}**Phase Context (if exists):**{context_content}**Research (if exists):**{research_content}**Gap Closure (if --gaps mode):**{verification_content}{uat_content}</planning_context><downstream_consumer>Output consumed by /gsd:execute-phasePlans must be executable prompts with:- Frontmatter (wave, depends_on, files_modified, autonomous)- Tasks in XML format- Verification criteria- must_haves for goal-backward verification</downstream_consumer><quality_gate>Before returning PLANNING COMPLETE:- [ ] PLAN.md files created in phase directory- [ ] Each plan has valid frontmatter- [ ] Tasks are specific and actionable- [ ] Dependencies correctly identified- [ ] Waves assigned for parallel execution- [ ] must_haves derived from phase goal</quality_gate>```text```csv
```css```text
```text```bash# Read all plans in phase directoryPLANS_CONTENT=$(cat "${PHASE_DIR}"/*-PLAN.md 2>/dev/null)# Read requirements (reuse from step 7 if available)REQUIREMENTS_CONTENT=$(cat .planning/REQUIREMENTS.md 2>/dev/null)```text```markdown<verification_context>**Phase:** {phase_number}**Phase Goal:** {goal from ROADMAP}**Plans to verify:**{plans_content}**Requirements (if exists):**{requirements_content}</verification_context><expected_output>Return one of:- ## VERIFICATION PASSED — all checks pass- ## ISSUES FOUND — structured issue list</expected_output>```text```csv
```css```bashPLANS_CONTENT=$(cat "${PHASE_DIR}"/*-PLAN.md 2>/dev/null)```text```markdown<revision_context>**Phase:** {phase_number}**Mode:** revision**Existing plans:**{plans_content}**Checker issues:**{structured_issues_from_checker}</revision_context><instructions>Make targeted updates to address checker issues.Do NOT replan from scratch unless issues are fundamental.Return what changed.</instructions>```text```csv
```- After planner returns → spawn checker again (step 10)- Increment iteration_count**If iteration_count >= 3:**Display: `Max iterations reached. {N} issues remain:`- List remaining issuesOffer options:1. Force proceed (execute despite issues)2. Provide guidance (user gives direction, retry)3. Abandon (exit planning)Wait for user response.## 13. Present Final StatusRoute to `<offer_next>`.</process><offer_next>Output this markdown directly (not as a code block):━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ GSD ► PHASE {X} PLANNED ✓━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━**Phase {X}: {Name}** — {N} plan(s) in {M} wave(s)| Wave | Plans | What it builds ||------|-------|----------------|| 1    | 01, 02 | [objectives] || 2    | 03     | [objective]  |Research: {Completed | Used existing | Skipped}Verification: {Passed | Passed with override | Skipped}───────────────────────────────────────────────────────────────## ▶ Next Up**Execute Phase {X}** — run all {N} plans/gsd:execute-phase {X}<sub>/clear first → fresh context window</sub>───────────────────────────────────────────────────────────────**Also available:**- cat .planning/phases/{phase-dir}/*-PLAN.md — review plans- /gsd:plan-phase {X} --research — re-research first───────────────────────────────────────────────────────────────</offer_next><success_criteria>- [ ] .planning/ directory validated- [ ] Phase validated against roadmap- [ ] Phase directory created if needed- [ ] Research completed (unless --skip-research or --gaps or exists)- [ ] gsd-phase-researcher spawned if research needed- [ ] Existing plans checked- [ ] gsd-planner spawned with context (including RESEARCH.md if available)- [ ] Plans created (PLANNING COMPLETE or CHECKPOINT handled)- [ ] gsd-plan-checker spawned (unless --skip-verify)- [ ] Verification passed OR user override OR max iterations with user decision- [ ] User sees status between agent spawns- [ ] User knows next steps (execute or review)</success_criteria>