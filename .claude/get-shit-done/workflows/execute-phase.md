<purpose>Execute all plans in a phase using wave-based parallel execution. Orchestrator stays lean by delegating plan execution to subagents.</purpose><core_principle>The orchestrator's job is coordination, not execution. Each subagent loads the full execute-plan context itself. Orchestrator discovers plans, analyzes dependencies, groups into waves, spawns agents, handles checkpoints, collects results.</core_principle><required_reading>Read STATE.md before any operation to load project context.Read config.json for planning behavior settings.</required_reading><process><step name="resolve_model_profile" priority="first">Read model profile for agent spawning:```bashMODEL_PROFILE=$(cat .planning/config.json 2>/dev/null | grep -o '"model_profile"[[:space:]]*:[[:space:]]*"[^"]*"' | grep -o '"[^"]*"$' | tr -d '"' || echo "balanced")```text```bashcat .planning/STATE.md 2>/dev/null```csv```text
```text```bash# Check if planning docs should be committed (default: true)COMMIT_PLANNING_DOCS=$(cat .planning/config.json 2>/dev/null | grep -o '"commit_docs"[[:space:]]*:[[:space:]]*[^,}]*' | grep -o 'true\|false' || echo "true")# Auto-detect gitignored (overrides config)git check-ignore -q .planning 2>/dev/null && COMMIT_PLANNING_DOCS=false```html```bash# Match both zero-padded (05-*) and unpadded (5-*) foldersPADDED_PHASE=$(printf "%02d" ${PHASE_ARG} 2>/dev/null || echo "${PHASE_ARG}")PHASE_DIR=$(ls -d .planning/phases/${PADDED_PHASE}-* .planning/phases/${PHASE_ARG}-* 2>/dev/null | head -1)if [ -z "$PHASE_DIR" ]; then  echo "ERROR: No phase directory matching '${PHASE_ARG}'"  exit 1fiPLAN_COUNT=$(ls -1 "$PHASE_DIR"/*-PLAN.md 2>/dev/null | wc -l | tr -d ' ')if [ "$PLAN_COUNT" -eq 0 ]; then  echo "ERROR: No plans found in $PHASE_DIR"  exit 1fi```html```bash# Get all plansls -1 "$PHASE_DIR"/*-PLAN.md 2>/dev/null | sort# Get completed plans (have SUMMARY.md)ls -1 "$PHASE_DIR"/*-SUMMARY.md 2>/dev/null | sort```markdown```bash# For each plan, extract wave from frontmatterfor plan in $PHASE_DIR/*-PLAN.md; do  wave=$(grep "^wave:" "$plan" | cut -d: -f2 | tr -d ' ')  autonomous=$(grep "^autonomous:" "$plan" | cut -d: -f2 | tr -d ' ')  echo "$plan:$wave:$autonomous"done```text```csv
```text```bash
```html```markdown## Phase {X}: {Name} Execution Complete**Waves executed:** {N}**Plans completed:** {M} of {total}### Wave Summary| Wave | Plans | Status ||------|-------|--------|| 1 | plan-01, plan-02 | ✓ Complete || CP | plan-03 | ✓ Verified || 2 | plan-04 | ✓ Complete || 3 | plan-05 | ✓ Complete |### Plan Details1. **03-01**: [one-liner from SUMMARY.md]2. **03-02**: [one-liner from SUMMARY.md]...### Issues Encountered[Aggregate from all SUMMARYs, or "None"]```html```csv
```text```bashgrep "^status:" "$PHASE_DIR"/*-VERIFICATION.md | cut -d: -f2 | tr -d ' '```text```markdown## ✓ Phase {X}: {Name} — Human Verification RequiredAll automated checks passed. {N} items need human testing:### Human Verification Checklist{Extract from VERIFICATION.md human_verification section}---**After testing:**- "approved" → continue to update_roadmap- Report issues → will route to gap closure planning```text```markdown## ⚠ Phase {X}: {Name} — Gaps Found**Score:** {N}/{M} must-haves verified**Report:** {phase_dir}/{phase}-VERIFICATION.md### What's Missing{Extract gap summaries from VERIFICATION.md gaps section}---## ▶ Next Up**Plan gap closure** — create additional plans to complete the phase`/gsd:plan-phase {X} --gaps`<sub>`/clear` first → fresh context window</sub>---**Also available:**- `cat {phase_dir}/{phase}-VERIFICATION.md` — see full report- `/gsd:verify-work {X}` — manual testing before planning```csv```bash# Mark phase complete# Update completion date# Update status```markdown```bashgit add .planning/ROADMAP.md .planning/STATE.md .planning/phases/{phase_dir}/*-VERIFICATION.mdgit add .planning/REQUIREMENTS.md  # if updatedgit commit -m "docs(phase-{X}): complete phase execution"```html```bash
```text```text
```</step></process><context_efficiency>Orchestrator: ~10-15% context (frontmatter, spawning, results).Subagents: Fresh 200k each (full workflow + execution).No polling (Task blocks). No context bleed.</context_efficiency><failure_handling>**Subagent fails mid-plan:**- SUMMARY.md won't exist- Orchestrator detects missing SUMMARY- Reports failure, asks user how to proceed**Dependency chain breaks:**- Wave 1 plan fails- Wave 2 plans depending on it will likely fail- Orchestrator can still attempt them (user choice)- Or skip dependent plans entirely**All agents in wave fail:**- Something systemic (git issues, permissions, etc.)- Stop execution- Report for manual investigation**Checkpoint fails to resolve:**- User can't approve or provides repeated issues- Ask: "Skip this plan?" or "Abort phase execution?"- Record partial progress in STATE.md</failure_handling><resumption>**Resuming interrupted execution:**If phase execution was interrupted (context limit, user exit, error):1. Run `/gsd:execute-phase {phase}` again2. discover_plans finds completed SUMMARYs3. Skips completed plans4. Resumes from first incomplete plan5. Continues wave-based execution**STATE.md tracks:**- Last completed plan- Current wave- Any pending checkpoints</resumption>