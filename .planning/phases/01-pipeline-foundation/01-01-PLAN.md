---
phase: 01-pipeline-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/db/index.ts
  - services/contract/pipeline/types.ts
  - services/contract/pipeline/dedup.ts
  - services/contract/pipeline/watcher.ts
  - services/contract/pipeline/index.ts
  - services/contract/pipeline/watcher.test.ts
autonomous: true

must_haves:
  truths:
    - "New PDF is detected within 3 seconds of being added to the watched folder"
    - "Adding the same PDF filename twice only triggers one processing event"
    - "Pressing Ctrl+C stops the watcher and exits cleanly without errors"
    - "Text files and other non-PDF files dropped in the folder are ignored"
  artifacts:
    - path: "services/contract/pipeline/watcher.ts"
      provides: "Chokidar file watcher with PDF filtering"
      min_lines: 40
    - path: "services/contract/pipeline/dedup.ts"
      provides: "SQLite-based deduplication functions"
      exports: ["isAlreadyProcessed", "markAsProcessed"]
    - path: "services/contract/pipeline/index.ts"
      provides: "Main pipeline entrypoint"
      exports: ["startPipeline", "stopPipeline"]
    - path: "lib/db/index.ts"
      provides: "processed_contracts table schema"
      contains: "CREATE TABLE IF NOT EXISTS processed_contracts"
    - path: "services/contract/pipeline/watcher.test.ts"
      provides: "Integration test for watcher behavior"
      min_lines: 50
  key_links:
    - from: "services/contract/pipeline/watcher.ts"
      to: "services/contract/pipeline/dedup.ts"
      via: "import { isAlreadyProcessed, markAsProcessed }"
      pattern: "isAlreadyProcessed|markAsProcessed"
    - from: "services/contract/pipeline/index.ts"
      to: "services/contract/pipeline/watcher.ts"
      via: "import { startWatcher, stopWatcher }"
      pattern: "startWatcher|stopWatcher"
---

<objective>
Implement the contract pipeline foundation: a folder watcher that detects new PDFs and triggers processing, with SQLite-based deduplication to prevent reprocessing.

Purpose: This is the entry point for the entire Contract Cascade system. Without reliable PDF detection, no downstream processing can occur.

Output: A working `services/contract/pipeline/` module that watches a configurable folder, detects new PDFs, deduplicates by filename, and calls a handler callback.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-pipeline-foundation/01-RESEARCH.md
@lib/db/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add processed_contracts table and chokidar dependency</name>
  <files>lib/db/index.ts, package.json</files>
  <action>
    1. Run `bun add chokidar` to install the file watcher dependency

    2. Add the processed_contracts table to lib/db/index.ts (after the monday_cache table):
    ```sql
    CREATE TABLE IF NOT EXISTS processed_contracts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      filename TEXT NOT NULL UNIQUE,
      file_path TEXT NOT NULL,
      processed_at TEXT NOT NULL DEFAULT (datetime('now')),
      status TEXT NOT NULL DEFAULT 'pending'
    )
    ```

    3. Add index for filename lookups:
    ```sql
    CREATE INDEX IF NOT EXISTS idx_processed_contracts_filename ON processed_contracts(filename)
    ```

    Follow the existing pattern in lib/db/index.ts for table definitions (use db.run with template literal SQL).
  </action>
  <verify>
    - `bun run -e "import { db } from './lib/db'; console.log(db.query('SELECT name FROM sqlite_master WHERE type=\"table\" AND name=\"processed_contracts\"').get())"` returns the table name
    - `grep chokidar package.json` shows the dependency
  </verify>
  <done>
    - processed_contracts table exists in SQLite schema
    - chokidar is in package.json dependencies
  </done>
</task>

<task type="auto">
  <name>Task 2: Create pipeline types and deduplication module</name>
  <files>services/contract/pipeline/types.ts, services/contract/pipeline/dedup.ts</files>
  <action>
    1. Create services/contract/pipeline/types.ts with pipeline types:
    ```typescript
    export type ProcessingStatus = "pending" | "processing" | "completed" | "failed";

    export type ProcessedContract = {
      id: number;
      filename: string;
      filePath: string;
      processedAt: string;
      status: ProcessingStatus;
    };

    export type PipelineHandler = (filePath: string) => Promise<void>;
    ```

    2. Create services/contract/pipeline/dedup.ts with deduplication functions:
    - Import db from "@/lib/db"
    - Import path from "node:path" for basename extraction
    - isAlreadyProcessed(filePath: string): Promise<boolean> - checks if filename exists in processed_contracts
    - markAsProcessed(filePath: string, status?: ProcessingStatus): Promise<void> - inserts filename and path
    - Use synchronous Bun SQLite API (db.query().get() and db.run())
    - Functions can be sync since bun:sqlite is sync, but mark as async for future-proofing

    Pattern from research:
    ```typescript
    export function isAlreadyProcessed(filePath: string): boolean {
      const filename = path.basename(filePath);
      const row = db.query("SELECT 1 FROM processed_contracts WHERE filename = ?").get(filename);
      return row !== null;
    }
    ```
  </action>
  <verify>
    - `bun run -e "import { isAlreadyProcessed, markAsProcessed } from './services/contract/pipeline/dedup'"` runs without error
    - TypeScript compiles: `bunx tsc --noEmit services/contract/pipeline/types.ts services/contract/pipeline/dedup.ts`
  </verify>
  <done>
    - types.ts defines ProcessingStatus, ProcessedContract, PipelineHandler
    - dedup.ts exports isAlreadyProcessed and markAsProcessed
    - Functions interact correctly with SQLite
  </done>
</task>

<task type="auto">
  <name>Task 3a: Create file watcher module</name>
  <files>services/contract/pipeline/watcher.ts</files>
  <action>
    Create services/contract/pipeline/watcher.ts:
    - Import chokidar (default import)
    - Import isAlreadyProcessed, markAsProcessed from "./dedup"
    - Import PipelineHandler from "./types"
    - Define WATCH_DIR from process.env.CONTRACT_WATCH_DIR ?? "./contracts"
    - Store watcher instance in module-level variable
    - startWatcher(onNewPdf: PipelineHandler): Promise<void>
      - Initialize chokidar.watch with options from research:
        - persistent: true
        - ignoreInitial: true (don't process existing files on startup)
        - awaitWriteFinish: { stabilityThreshold: 2000, pollInterval: 100 }
        - ignored: /(^|[\/\\])\../ (ignore dotfiles)
      - On "add" event: check if PDF, check dedup, mark processed, call handler
      - On "ready" event: log that watcher is ready
      - On "error" event: log error (don't crash)
    - stopWatcher(): Promise<void> - close watcher if exists

    Key implementation details from research:
    - Use async handler for watcher events
    - Check filePath.toLowerCase().endsWith(".pdf") before processing
    - Log file paths on detection
    - Handle errors in try/catch, log but don't crash
  </action>
  <verify>
    - `bun run -e "import { startWatcher, stopWatcher } from './services/contract/pipeline/watcher'"` runs without error
    - TypeScript compiles: `bunx tsc --noEmit services/contract/pipeline/watcher.ts`
  </verify>
  <done>
    - watcher.ts exports startWatcher and stopWatcher functions
    - Watcher filters for PDF files only
    - Watcher integrates with dedup module
  </done>
</task>

<task type="auto">
  <name>Task 3b: Create main pipeline entrypoint</name>
  <files>services/contract/pipeline/index.ts</files>
  <action>
    Create services/contract/pipeline/index.ts:
    - Import startWatcher, stopWatcher from "./watcher"
    - Re-export types from "./types"
    - Export startPipeline and stopPipeline (wrapper functions)
    - Add graceful shutdown handlers for SIGINT and SIGTERM
    - Include a main() function for direct execution:
    ```typescript
    async function main() {
      await startPipeline(async (filePath) => {
        console.log(`[Pipeline] Processing: ${filePath}`);
        // Placeholder - future phases will add real processing
      });
      console.log("Pipeline running. Press Ctrl+C to stop.");
    }

    // Run if executed directly
    if (import.meta.main) {
      main();
    }
    ```
  </action>
  <verify>
    - `bun run -e "import { startPipeline, stopPipeline } from './services/contract/pipeline'; console.log('imports ok')"` prints "imports ok"
  </verify>
  <done>
    - index.ts provides startPipeline/stopPipeline exports
    - Graceful shutdown handlers registered for SIGINT/SIGTERM
    - Can be run directly with `bun run services/contract/pipeline/index.ts`
  </done>
</task>

<task type="auto">
  <name>Task 3c: Create integration test for watcher</name>
  <files>services/contract/pipeline/watcher.test.ts</files>
  <action>
    Create services/contract/pipeline/watcher.test.ts using Bun's test framework:

    ```typescript
    import { describe, it, expect, beforeEach, afterEach } from "bun:test";
    import { mkdtemp, rm, writeFile } from "node:fs/promises";
    import { tmpdir } from "node:os";
    import path from "node:path";
    import { startWatcher, stopWatcher } from "./watcher";
    import { db } from "@/lib/db";

    describe("contract pipeline watcher", () => {
      let testDir: string;
      let processedFiles: string[];

      beforeEach(async () => {
        // Create unique temp directory for each test
        testDir = await mkdtemp(path.join(tmpdir(), "watcher-test-"));
        processedFiles = [];

        // Set watch directory via env
        process.env.CONTRACT_WATCH_DIR = testDir;

        // Clean up test entries from previous runs
        db.run("DELETE FROM processed_contracts WHERE filename LIKE 'test-%'");
      });

      afterEach(async () => {
        await stopWatcher();
        await rm(testDir, { recursive: true, force: true });
        delete process.env.CONTRACT_WATCH_DIR;
      });

      it("detects new PDF files", async () => {
        const handler = async (filePath: string) => {
          processedFiles.push(filePath);
        };

        await startWatcher(handler);

        // Wait for watcher to be ready
        await Bun.sleep(500);

        // Create a PDF file
        const pdfPath = path.join(testDir, "test-new.pdf");
        await writeFile(pdfPath, "fake pdf content");

        // Wait for detection (awaitWriteFinish + processing)
        await Bun.sleep(3000);

        expect(processedFiles.length).toBe(1);
        expect(processedFiles[0]).toContain("test-new.pdf");
      });

      it("ignores non-PDF files", async () => {
        const handler = async (filePath: string) => {
          processedFiles.push(filePath);
        };

        await startWatcher(handler);
        await Bun.sleep(500);

        // Create non-PDF files
        await writeFile(path.join(testDir, "test-ignore.txt"), "text content");
        await writeFile(path.join(testDir, "test-ignore.docx"), "docx content");

        await Bun.sleep(3000);

        expect(processedFiles.length).toBe(0);
      });

      it("does not process duplicate filenames", async () => {
        const handler = async (filePath: string) => {
          processedFiles.push(filePath);
        };

        await startWatcher(handler);
        await Bun.sleep(500);

        // Create first PDF
        const pdfPath = path.join(testDir, "test-dedup.pdf");
        await writeFile(pdfPath, "first content");
        await Bun.sleep(3000);

        // Delete and recreate same filename
        await rm(pdfPath);
        await writeFile(pdfPath, "second content");
        await Bun.sleep(3000);

        // Should only process once
        expect(processedFiles.length).toBe(1);
      });

      it("stops cleanly without errors", async () => {
        const handler = async (_filePath: string) => {};

        await startWatcher(handler);
        await Bun.sleep(500);

        // Should not throw
        await expect(stopWatcher()).resolves.toBeUndefined();
      });
    });
    ```

    Key test requirements:
    - Use temp directories (mkdtemp) for isolation
    - Clean up in afterEach (stop watcher, remove temp dir)
    - Allow time for awaitWriteFinish (3s waits)
    - Test: PDF detection, non-PDF ignored, deduplication, clean shutdown
  </action>
  <verify>
    Run the test file:
    ```bash
    bun test services/contract/pipeline/watcher.test.ts
    ```
    All 4 tests should pass.
  </verify>
  <done>
    - watcher.test.ts exists with 4 tests
    - Tests cover: PDF detection, non-PDF filtering, deduplication, clean shutdown
    - All tests pass when run with `bun test`
  </done>
</task>

</tasks>

<verification>
After all tasks complete, run end-to-end verification:

1. **Schema check:**
   ```bash
   bun run -e "import { db } from './lib/db'; const t = db.query('SELECT sql FROM sqlite_master WHERE name=\"processed_contracts\"').get(); console.log(t)"
   ```
   Should show CREATE TABLE statement.

2. **Dependency check:**
   ```bash
   bun pm ls | grep chokidar
   ```
   Should show chokidar version.

3. **Import check:**
   ```bash
   bun run -e "import { startPipeline, stopPipeline } from './services/contract/pipeline'; console.log('imports ok')"
   ```
   Should print "imports ok".

4. **Test suite:**
   ```bash
   bun test services/contract/pipeline/watcher.test.ts
   ```
   All 4 tests should pass:
   - detects new PDF files
   - ignores non-PDF files
   - does not process duplicate filenames
   - stops cleanly without errors

5. **Lint check:**
   ```bash
   bunx ultracite check services/contract/pipeline/
   ```
   Should pass with no errors.
</verification>

<success_criteria>
Phase 1 requirements satisfied:

- [TRIG-01] System watches a folder for new PDF files
  - Verified by: watcher.ts using chokidar with PDF extension filter

- [TRIG-02] New PDF detection triggers processing pipeline
  - Verified by: onNewPdf callback invoked when PDF added

- [TRIG-03] Supports local folder (can add SharePoint later)
  - Verified by: WATCH_DIR configurable via environment variable
  - Architecture allows swapping watcher implementation in future

Additional:
- Deduplication prevents reprocessing same filename
- Graceful shutdown on SIGINT/SIGTERM
- Error handling prevents crashes on watcher errors
- Integration tests verify all behaviors programmatically
</success_criteria>

<output>
After completion, create `.planning/phases/01-pipeline-foundation/01-01-SUMMARY.md` using the summary template.
</output>
