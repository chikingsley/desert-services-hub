---
phase: 03-multi-agent-extraction
plan: 03
type: execute
wave: 3
depends_on: ["03-02"]
files_modified:
  - services/contract/agents/orchestrator.ts
  - services/contract/pipeline/index.ts
autonomous: true

must_haves:
  truths:
    - "All 7 agents run in parallel using Promise.allSettled"
    - "Partial failures do not crash the entire extraction"
    - "Agent results are stored in SQLite after extraction"
    - "Pipeline processes contracts through extraction automatically"
  artifacts:
    - path: "services/contract/agents/orchestrator.ts"
      provides: "runAllAgents function"
      exports: ["runAllAgents"]
    - path: "services/contract/pipeline/index.ts"
      provides: "Pipeline with extraction integration"
      contains: "runAllAgents"
  key_links:
    - from: "services/contract/agents/orchestrator.ts"
      to: "services/contract/agents/extractors/*.ts"
      via: "function imports"
      pattern: "import.*extract.*from.*extractors"
    - from: "services/contract/agents/orchestrator.ts"
      to: "services/contract/agents/storage.ts"
      via: "storeAgentResult call"
      pattern: "storeAgentResult"
    - from: "services/contract/pipeline/index.ts"
      to: "services/contract/agents/orchestrator.ts"
      via: "runAllAgents integration"
      pattern: "runAllAgents"
    - from: "services/contract/pipeline/index.ts"
      to: "services/contract/extraction/storage.ts"
      via: "getFullText call"
      pattern: "getFullText"
---

<objective>
Create the parallel orchestrator that runs all 7 agents simultaneously and integrate extraction into the contract processing pipeline.

Purpose: Enable parallel agent execution for speed (EXTR-08) and wire extraction into the existing pipeline
Output: Working end-to-end extraction when contract PDFs are dropped in watch folder
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-multi-agent-extraction/03-RESEARCH.md
@.planning/phases/03-multi-agent-extraction/03-01-SUMMARY.md
@.planning/phases/03-multi-agent-extraction/03-02-SUMMARY.md
@services/contract/pipeline/index.ts
@services/contract/extraction/storage.ts
@services/contract/agents/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create parallel orchestrator with Promise.allSettled</name>
  <files>services/contract/agents/orchestrator.ts</files>
  <action>
Create the orchestrator that runs all 7 agents in parallel.

**services/contract/agents/orchestrator.ts:**

```typescript
import type { Mistral } from "@mistralai/mistralai";
import type { AgentName, AgentResult } from "./types";
import { storeAgentResult } from "./storage";
import { extractContractInfo } from "./extractors/contract-info";
import { extractBilling } from "./extractors/billing";
import { extractContacts } from "./extractors/contacts";
import { extractSOV } from "./extractors/sov";
import { extractInsurance } from "./extractors/insurance";
import { extractSiteInfo } from "./extractors/site-info";
import { extractRedFlags } from "./extractors/red-flags";

type AgentDefinition = {
  name: AgentName;
  fn: (fullText: string, mistral: Mistral) => Promise<unknown>;
};

const AGENTS: AgentDefinition[] = [
  { name: "contractInfo", fn: extractContractInfo },
  { name: "billing", fn: extractBilling },
  { name: "contacts", fn: extractContacts },
  { name: "sov", fn: extractSOV },
  { name: "insurance", fn: extractInsurance },
  { name: "siteInfo", fn: extractSiteInfo },
  { name: "redFlags", fn: extractRedFlags },
];

/**
 * Run all extraction agents in parallel.
 * Uses Promise.allSettled to handle partial failures gracefully.
 * Each agent result is stored in SQLite regardless of success/failure.
 *
 * @param contractId - The contract ID to associate results with
 * @param fullText - Full document text with page breaks
 * @param mistral - Mistral client instance
 * @returns Map of agent names to their results
 */
export async function runAllAgents(
  contractId: number,
  fullText: string,
  mistral: Mistral
): Promise<Map<AgentName, AgentResult<unknown>>> {
  const startTime = Date.now();

  // Run all agents in parallel
  const results = await Promise.allSettled(
    AGENTS.map(async (agent) => {
      const agentStart = Date.now();
      try {
        const data = await agent.fn(fullText, mistral);
        const durationMs = Date.now() - agentStart;

        // Store successful result
        storeAgentResult(contractId, agent.name, data, "success", null, durationMs);

        return {
          agentName: agent.name,
          status: "success" as const,
          data,
          durationMs,
        };
      } catch (error) {
        const durationMs = Date.now() - agentStart;
        const errorMessage = error instanceof Error ? error.message : String(error);

        // Store failed result
        storeAgentResult(contractId, agent.name, null, "error", errorMessage, durationMs);

        return {
          agentName: agent.name,
          status: "error" as const,
          error: errorMessage,
          durationMs,
        };
      }
    })
  );

  // Collect results into a map
  const resultMap = new Map<AgentName, AgentResult<unknown>>();
  for (const result of results) {
    if (result.status === "fulfilled") {
      resultMap.set(result.value.agentName, result.value);
    }
  }

  const totalDuration = Date.now() - startTime;
  const successCount = [...resultMap.values()].filter((r) => r.status === "success").length;
  const errorCount = [...resultMap.values()].filter((r) => r.status === "error").length;

  // Log summary (will be visible in pipeline output)
  console.log(
    `[Extraction] Completed ${resultMap.size} agents in ${totalDuration}ms (${successCount} success, ${errorCount} errors)`
  );

  return resultMap;
}

/**
 * Get a summary of extraction results for logging/display.
 */
export function summarizeResults(
  results: Map<AgentName, AgentResult<unknown>>
): { success: AgentName[]; errors: Array<{ agent: AgentName; error: string }> } {
  const success: AgentName[] = [];
  const errors: Array<{ agent: AgentName; error: string }> = [];

  for (const [name, result] of results) {
    if (result.status === "success") {
      success.push(name);
    } else if (result.error) {
      errors.push({ agent: name, error: result.error });
    }
  }

  return { success, errors };
}
```

Key design decisions:
- Promise.allSettled (not Promise.all) so one failure doesn't crash everything
- Each agent stores its own result immediately after completion
- Summary logging shows timing and success/error counts
- Results returned as Map for easy lookup by agent name
  </action>
  <verify>
```bash
bun -e "
import { runAllAgents, summarizeResults } from './services/contract/agents/orchestrator';
console.log('runAllAgents is function:', typeof runAllAgents === 'function');
console.log('summarizeResults is function:', typeof summarizeResults === 'function');
"
```
  </verify>
  <done>Orchestrator exports runAllAgents that runs all 7 agents in parallel using Promise.allSettled. Results are stored in SQLite. Partial failures are handled gracefully.</done>
</task>

<task type="auto">
  <name>Task 2: Integrate extraction into pipeline</name>
  <files>services/contract/pipeline/index.ts</files>
  <action>
Update the pipeline to run extraction after text extraction completes.

**Modify services/contract/pipeline/index.ts:**

1. Add imports at top:
```typescript
import { getFullText } from "../extraction/storage";
import { runAllAgents, summarizeResults } from "../agents/orchestrator";
import { createMistralClient } from "../agents/mistral-client";
```

2. Update the onContract handler (the function called when a new PDF is detected) to:
   - After text extraction succeeds, get the full text
   - Create Mistral client
   - Run all extraction agents
   - Log extraction summary
   - Handle extraction errors without crashing pipeline

The pipeline flow should be:
```
PDF detected -> dedup check -> text extraction -> AGENT EXTRACTION -> mark complete
```

Example integration pattern:
```typescript
// Inside the handler after extractText succeeds:
try {
  // Get full text for agents
  const fullText = getFullText(contractId);
  if (!fullText || fullText.trim().length === 0) {
    console.error(`[Pipeline] No text extracted for contract ${contractId}, skipping extraction`);
  } else {
    // Run extraction agents
    const mistral = createMistralClient();
    const results = await runAllAgents(contractId, fullText, mistral);
    const summary = summarizeResults(results);

    if (summary.errors.length > 0) {
      console.warn(`[Pipeline] ${summary.errors.length} agent(s) failed:`, summary.errors);
    }

    console.log(`[Pipeline] Extraction complete for ${filename}: ${summary.success.length}/7 agents succeeded`);
  }
} catch (error) {
  // Log but don't crash - text extraction succeeded, that's the main goal
  console.error(`[Pipeline] Extraction failed for ${filename}:`, error);
}
```

Important: Extraction failures should NOT prevent the pipeline from marking the contract as processed. Text extraction is the critical path; agent extraction is valuable but not blocking.
  </action>
  <verify>
```bash
# Check pipeline imports work
bun -e "
import { startPipeline, stopPipeline } from './services/contract/pipeline';
console.log('Pipeline imports work');
console.log('startPipeline is function:', typeof startPipeline === 'function');
"

# Check full integration by examining the file
grep -l "runAllAgents" services/contract/pipeline/index.ts && echo "runAllAgents integrated into pipeline"
```
  </verify>
  <done>Pipeline calls runAllAgents after text extraction. Extraction errors are logged but do not crash pipeline. Full end-to-end flow works: PDF drop -> text extraction -> agent extraction -> storage.</done>
</task>

</tasks>

<verification>
End-to-end extraction working:
- [ ] runAllAgents function imports and works
- [ ] Pipeline imports extraction components without error
- [ ] Pipeline code calls runAllAgents after text extraction
- [ ] Extraction errors don't crash pipeline
- [ ] No lint errors: `bun x ultracite check`

Manual verification (requires MISTRAL_API_KEY):
```bash
# Start pipeline in one terminal
CONTRACT_WATCH_DIR=/tmp/test-contracts bun run services/contract/pipeline/index.ts

# In another terminal, drop a test PDF
cp /path/to/test.pdf /tmp/test-contracts/

# Should see:
# [Pipeline] Processing: test.pdf
# [Extraction] Completed 7 agents in XXXms (N success, M errors)
# [Pipeline] Extraction complete for test.pdf: N/7 agents succeeded
```
</verification>

<success_criteria>
- runAllAgents runs 7 agents in parallel (Promise.allSettled)
- Each agent result stored in contract_extractions table
- Pipeline integrates extraction without blocking on failures
- No TypeScript or lint errors
- Requirements satisfied: EXTR-08 (parallel), EXTR-09 (Zod validated), EXTR-10 (citations via pageReferences)
</success_criteria>

<output>
After completion, create `.planning/phases/03-multi-agent-extraction/03-03-SUMMARY.md`
</output>
