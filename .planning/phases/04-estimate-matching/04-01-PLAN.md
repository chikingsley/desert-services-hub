---
phase: 04-estimate-matching
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - services/contract/agents/schemas/contract-info.ts
  - services/contract/matching/types.ts
  - services/contract/matching/scorer.ts
  - services/contract/matching/matcher.ts
  - services/contract/matching/storage.ts
  - lib/db/index.ts
autonomous: true

must_haves:
  truths:
    - "Contract can be matched to Monday ESTIMATING board items"
    - "Matching uses both project name and contractor for scoring"
    - "High-confidence matches (>0.8) are flagged as auto_matched"
    - "Low-confidence matches return top candidates for selection"
    - "Match results are stored in SQLite with audit trail"
  artifacts:
    - path: "services/contract/agents/schemas/contract-info.ts"
      provides: "ContractInfo schema with generalContractor field"
      contains: "generalContractor"
    - path: "services/contract/matching/types.ts"
      provides: "MatchCandidate, MatchResult, MatchType types"
      exports: ["MatchCandidate", "MatchResult", "MatchType"]
    - path: "services/contract/matching/scorer.ts"
      provides: "Multi-field similarity scoring"
      exports: ["calculateMatchScore", "WEIGHTS", "HIGH_CONFIDENCE_THRESHOLD"]
    - path: "services/contract/matching/matcher.ts"
      provides: "Main matching entry point"
      exports: ["findEstimateMatch"]
    - path: "services/contract/matching/storage.ts"
      provides: "Match result persistence"
      exports: ["storeMatchResult", "getMatchForContract"]
  key_links:
    - from: "services/contract/matching/matcher.ts"
      to: "services/monday/client.ts"
      via: "findBestMatches, searchItems, calculateSimilarity imports"
      pattern: "import.*from.*monday/client"
    - from: "services/contract/matching/matcher.ts"
      to: "services/contract/matching/scorer.ts"
      via: "calculateMatchScore function"
      pattern: "calculateMatchScore"
    - from: "services/contract/matching/storage.ts"
      to: "lib/db"
      via: "db import and SQL operations"
      pattern: "db\\.prepare|db\\.query"
---

<objective>
Create the core estimate matching module that fuzzy-matches contracts to Monday.com ESTIMATING board items using multi-field weighted scoring.

Purpose: Enable linking incoming contracts to their original estimates, which is critical for the contract cascade workflow. This module provides the matching algorithm and storage layer.

Output: A fully functional matching module at `services/contract/matching/` with types, scorer, matcher, and storage components. Also updates the contract-info schema to include generalContractor field for matching.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-estimate-matching/04-RESEARCH.md

# Existing infrastructure to use
@services/monday/client.ts - findBestMatches(), calculateSimilarity(), searchItems()
@services/monday/types.ts - BOARD_IDS, ESTIMATING_COLUMNS
@services/contract/agents/storage.ts - getAllExtractedData() for getting extracted contract info
@services/contract/agents/schemas/contract-info.ts - Schema to update with generalContractor
@lib/db/index.ts - SQLite database setup pattern
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add generalContractor to contract-info schema</name>
  <files>
    services/contract/agents/schemas/contract-info.ts
  </files>
  <action>
Update the ContractInfoSchema to include a `generalContractor` field for matching.

**Modify services/contract/agents/schemas/contract-info.ts:**

Add the `generalContractor` field after `projectName`:

```typescript
/**
 * Contract Info Schema (EXTR-01)
 * Extracts basic contract information: type, dates, value, project details.
 */
import { z } from "zod";

export const ContractInfoSchema = z.object({
  contractType: z
    .enum(["LOI", "Subcontract", "Work Order", "Amendment", "Unknown"])
    .describe("Type of contract document"),
  contractDate: z
    .string()
    .nullable()
    .describe(
      "Date contract was signed/dated, format: YYYY-MM-DD. Use null if not found."
    ),
  contractValue: z
    .number()
    .nullable()
    .describe(
      "Total contract value in USD, without currency symbols. Use null if not found."
    ),
  projectName: z.string().describe("Name of the project"),
  generalContractor: z
    .string()
    .nullable()
    .describe(
      "Name of the general contractor (GC) who issued this subcontract. This is typically the company name in the 'Contractor' or 'General Contractor' section, not Desert Services. Use null if not found."
    ),
  projectAddress: z
    .string()
    .nullable()
    .describe(
      "Full street address of the project site. Use null if not found."
    ),
  startDate: z
    .string()
    .nullable()
    .describe("Project start date, format: YYYY-MM-DD. Use null if not found."),
  endDate: z
    .string()
    .nullable()
    .describe(
      "Project completion/end date, format: YYYY-MM-DD. Use null if not found."
    ),
  pageReferences: z
    .array(z.number().int().positive())
    .describe("Page numbers where this information was found (1-indexed)"),
});

export type ContractInfo = z.infer<typeof ContractInfoSchema>;
```

This adds the `generalContractor` field that the matching system needs. The `.describe()` annotation guides the LLM to extract the GC name correctly.
  </action>
  <verify>
    `bun x tsc --noEmit services/contract/agents/schemas/contract-info.ts` compiles without errors
    `bunx ultracite check services/contract/agents/schemas/contract-info.ts` passes
  </verify>
  <done>
    - ContractInfoSchema includes generalContractor field with proper description
    - ContractInfo type includes generalContractor: string | null
    - File type-checks and lints cleanly
  </done>
</task>

<task type="auto">
  <name>Task 2: Create types and scorer module</name>
  <files>
    services/contract/matching/types.ts
    services/contract/matching/scorer.ts
  </files>
  <action>
Create two files in `services/contract/matching/`:

**types.ts** - Define all types for the matching system:
```typescript
export type MatchCandidate = {
  itemId: string;
  itemName: string;
  itemUrl: string;
  projectScore: number;      // Similarity of project names (0-1)
  contractorScore: number;   // Similarity of contractor names (0-1)
  combinedScore: number;     // Weighted combination
  estimateContractor: string | null;  // Contractor from Monday item
};

export type MatchResult =
  | { status: "auto_matched"; estimate: MatchCandidate; confidence: number }
  | { status: "needs_selection"; candidates: MatchCandidate[]; topConfidence: number }
  | { status: "no_match"; reason: string };

export type MatchType = "auto" | "manual";

export type StoredMatch = {
  contractId: number;
  estimateItemId: string;
  estimateItemName: string;
  matchType: MatchType;
  confidenceScore: number;
  matchedBy: string | null;  // null for auto, user identifier for manual
  matchedAt: string;
};
```

**scorer.ts** - Multi-field weighted scoring:
```typescript
import { calculateSimilarity } from "@/services/monday/client";

export const WEIGHTS = {
  projectName: 0.6,
  contractor: 0.4,
} as const;

export const HIGH_CONFIDENCE_THRESHOLD = 0.8;
export const MIN_CONFIDENCE_THRESHOLD = 0.3;
export const MAX_CANDIDATES = 5;

export function calculateMatchScore(
  contractProjectName: string,
  contractContractor: string,
  estimateName: string,
  estimateContractor: string | null
): { projectScore: number; contractorScore: number; combinedScore: number } {
  const projectScore = calculateSimilarity(contractProjectName, estimateName);

  // If no contractor in estimate, use project score only
  const contractorScore = estimateContractor
    ? calculateSimilarity(contractContractor, estimateContractor)
    : 0;

  // Weighted combination - if no contractor data, rely on project name alone
  const combinedScore = estimateContractor
    ? projectScore * WEIGHTS.projectName + contractorScore * WEIGHTS.contractor
    : projectScore;

  return { projectScore, contractorScore, combinedScore };
}
```

Both files should use explicit types and follow the codebase conventions (no barrel exports, prefer `type` over `interface`).
  </action>
  <verify>
    `bun x tsc --noEmit services/contract/matching/types.ts services/contract/matching/scorer.ts` compiles without errors
    `bunx ultracite check services/contract/matching/` passes
  </verify>
  <done>
    - types.ts exports MatchCandidate, MatchResult, MatchType, StoredMatch types
    - scorer.ts exports calculateMatchScore, WEIGHTS, HIGH_CONFIDENCE_THRESHOLD, MIN_CONFIDENCE_THRESHOLD, MAX_CANDIDATES
    - Both files type-check and lint cleanly
  </done>
</task>

<task type="auto">
  <name>Task 3: Create matcher and storage modules</name>
  <files>
    services/contract/matching/matcher.ts
    services/contract/matching/storage.ts
    lib/db/index.ts
  </files>
  <action>
**Add contract_matches table to lib/db/index.ts** - Add after the contract_extractions table definition (around line 250):
```typescript
// ============================================
// Contract Matches (Estimate Linking)
// ============================================
db.run(`
  CREATE TABLE IF NOT EXISTS contract_matches (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    contract_id INTEGER NOT NULL,
    estimate_item_id TEXT NOT NULL,
    estimate_item_name TEXT NOT NULL,
    match_type TEXT NOT NULL CHECK(match_type IN ('auto', 'manual')),
    confidence_score REAL NOT NULL,
    matched_at TEXT NOT NULL DEFAULT (datetime('now')),
    matched_by TEXT,
    FOREIGN KEY (contract_id) REFERENCES processed_contracts(id) ON DELETE CASCADE,
    UNIQUE(contract_id)
  )
`);

// Add index for contract matches
db.run(
  "CREATE INDEX IF NOT EXISTS idx_contract_matches_contract ON contract_matches(contract_id)"
);
```

**storage.ts** - Store and retrieve match decisions:
```typescript
import { db } from "@/lib/db";
import type { MatchCandidate, MatchType, StoredMatch } from "./types";

type MatchRow = {
  contract_id: number;
  estimate_item_id: string;
  estimate_item_name: string;
  match_type: string;
  confidence_score: number;
  matched_by: string | null;
  matched_at: string;
};

export function storeMatchResult(
  contractId: number,
  estimate: MatchCandidate,
  matchType: MatchType,
  matchedBy: string | null = null
): void {
  const stmt = db.prepare(`
    INSERT OR REPLACE INTO contract_matches
    (contract_id, estimate_item_id, estimate_item_name, match_type, confidence_score, matched_by)
    VALUES (?, ?, ?, ?, ?, ?)
  `);
  stmt.run(
    contractId,
    estimate.itemId,
    estimate.itemName,
    matchType,
    estimate.combinedScore,
    matchedBy
  );
}

export function getMatchForContract(contractId: number): StoredMatch | null {
  const row = db
    .query<MatchRow, [number]>(
      `SELECT contract_id, estimate_item_id, estimate_item_name, match_type,
              confidence_score, matched_by, matched_at
       FROM contract_matches
       WHERE contract_id = ?`
    )
    .get(contractId);

  if (!row) return null;

  return {
    contractId: row.contract_id,
    estimateItemId: row.estimate_item_id,
    estimateItemName: row.estimate_item_name,
    matchType: row.match_type as MatchType,
    confidenceScore: row.confidence_score,
    matchedBy: row.matched_by,
    matchedAt: row.matched_at,
  };
}
```

**matcher.ts** - Main matching entry point:
```typescript
import {
  findBestMatches,
  searchItems,
  type ScoredItem,
} from "@/services/monday/client";
import { BOARD_IDS } from "@/services/monday/types";
import {
  calculateMatchScore,
  HIGH_CONFIDENCE_THRESHOLD,
  MAX_CANDIDATES,
  MIN_CONFIDENCE_THRESHOLD,
} from "./scorer";
import type { MatchCandidate, MatchResult } from "./types";

/**
 * Find the best estimate match for a contract.
 * Uses parallel search (project name + contractor) and multi-field scoring.
 */
export async function findEstimateMatch(
  projectName: string,
  contractor: string
): Promise<MatchResult> {
  const boardId = BOARD_IDS.ESTIMATING;

  // Parallel search: fuzzy match by project name + keyword search by contractor first word
  const contractorFirstWord = contractor.split(" ")[0] ?? contractor;
  const [projectMatches, contractorMatches] = await Promise.all([
    findBestMatches(boardId, projectName, 10),
    searchItems(boardId, contractorFirstWord),
  ]);

  // Merge and dedupe results
  const seenIds = new Set<string>();
  const allItems: ScoredItem[] = [];

  for (const item of [...projectMatches, ...contractorMatches]) {
    if (!seenIds.has(item.id)) {
      seenIds.add(item.id);
      allItems.push(item);
    }
  }

  if (allItems.length === 0) {
    return {
      status: "no_match",
      reason: `No estimates found matching "${projectName}" or "${contractor}"`,
    };
  }

  // Score all items with multi-field algorithm
  const candidates: MatchCandidate[] = allItems
    .map((item) => {
      // Contractor is in deal_account column (mirror from Contractors board)
      const estimateContractor = item.columns?.["deal_account"] ?? null;

      const scores = calculateMatchScore(
        projectName,
        contractor,
        item.name,
        estimateContractor
      );

      return {
        itemId: item.id,
        itemName: item.name,
        itemUrl: item.url,
        estimateContractor,
        ...scores,
      };
    })
    .filter((c) => c.combinedScore >= MIN_CONFIDENCE_THRESHOLD)
    .sort((a, b) => b.combinedScore - a.combinedScore);

  if (candidates.length === 0) {
    return {
      status: "no_match",
      reason: "Found items but none met minimum confidence threshold",
    };
  }

  const topCandidate = candidates[0];

  // Auto-match if high confidence
  if (topCandidate.combinedScore >= HIGH_CONFIDENCE_THRESHOLD) {
    return {
      status: "auto_matched",
      estimate: topCandidate,
      confidence: topCandidate.combinedScore,
    };
  }

  // Return top candidates for human selection
  return {
    status: "needs_selection",
    candidates: candidates.slice(0, MAX_CANDIDATES),
    topConfidence: topCandidate.combinedScore,
  };
}
```

Use the existing patterns from the codebase. The matcher uses the existing `findBestMatches` and `calculateSimilarity` from the Monday client - do not recreate these functions.
  </action>
  <verify>
    `bun x tsc --noEmit services/contract/matching/*.ts` compiles without errors
    `bunx ultracite check services/contract/matching/` passes
    Database table created: `bun -e "import { db } from './lib/db'; console.log(db.query('SELECT name FROM sqlite_master WHERE type=\\'table\\' AND name=\\'contract_matches\\'').get())"`
  </verify>
  <done>
    - contract_matches table exists in SQLite schema
    - storage.ts exports storeMatchResult and getMatchForContract
    - matcher.ts exports findEstimateMatch that uses parallel search and multi-field scoring
    - All files type-check and lint cleanly
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `bunx ultracite check services/contract/matching/ services/contract/agents/schemas/contract-info.ts` - No lint errors
2. `bun x tsc --noEmit services/contract/matching/*.ts services/contract/agents/schemas/contract-info.ts` - No type errors
3. Database has contract_matches table: `bun -e "import { db } from './lib/db'; console.log('table exists:', !!db.query('SELECT name FROM sqlite_master WHERE type=\\'table\\' AND name=\\'contract_matches\\'').get())"`
4. ContractInfoSchema includes generalContractor field
</verification>

<success_criteria>
- services/contract/agents/schemas/contract-info.ts includes generalContractor field
- services/contract/matching/ directory exists with types.ts, scorer.ts, matcher.ts, storage.ts
- findEstimateMatch function performs multi-field fuzzy matching
- Match results can be stored and retrieved from SQLite
- No lint or type errors
</success_criteria>

<output>
After completion, create `.planning/phases/04-estimate-matching/04-01-SUMMARY.md`
</output>
