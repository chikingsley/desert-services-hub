---
phase: 04-estimate-matching
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - services/contract/pipeline/index.ts
  - services/contract/matching/link.ts
autonomous: false

must_haves:
  truths:
    - "Pipeline automatically attempts matching after extraction"
    - "Auto-matched contracts are linked to estimates in Monday"
    - "Low-confidence matches log candidates for human selection"
    - "Match failures don't crash the pipeline"
  artifacts:
    - path: "services/contract/matching/link.ts"
      provides: "Link contract to estimate in Monday"
      exports: ["processContractMatch", "selectEstimateMatch", "formatCandidatesForSelection"]
    - path: "services/contract/pipeline/index.ts"
      provides: "Pipeline with matching integration"
      contains: "runEstimateMatching"
  key_links:
    - from: "services/contract/pipeline/index.ts"
      to: "services/contract/matching/link.ts"
      via: "processContractMatch import"
      pattern: "import.*processContractMatch.*from.*matching"
    - from: "services/contract/matching/link.ts"
      to: "services/contract/agents/storage.ts"
      via: "getAllExtractedData call"
      pattern: "getAllExtractedData"
    - from: "services/contract/matching/link.ts"
      to: "services/contract/matching/storage.ts"
      via: "storeMatchResult call"
      pattern: "storeMatchResult"
---

<objective>
Integrate estimate matching into the contract pipeline and add linking functionality to connect matched contracts with their estimates in Monday.com.

Purpose: Complete the matching workflow so contracts are automatically linked to estimates when confidence is high, and candidates are surfaced for human selection when confidence is low.

Output: Updated pipeline that runs matching after extraction, plus linking module that stores match decisions and updates Monday.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-estimate-matching/04-RESEARCH.md

# Dependencies from Plan 01
@services/contract/matching/types.ts
@services/contract/matching/matcher.ts
@services/contract/matching/storage.ts

# Schema with generalContractor field (updated in Plan 01)
@services/contract/agents/schemas/contract-info.ts

# Pipeline to integrate with
@services/contract/pipeline/index.ts

# Extraction storage for getting contract data
@services/contract/agents/storage.ts - getAllExtractedData()

# Monday client for linking
@services/monday/client.ts - updateItem()
@services/monday/types.ts - BOARD_IDS, ESTIMATING_COLUMNS
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create link module for Monday integration</name>
  <files>
    services/contract/matching/link.ts
  </files>
  <action>
Create a module that handles linking contracts to estimates and orchestrating the match workflow.

**link.ts**:
```typescript
import { getAllExtractedData } from "@/services/contract/agents/storage";
import type { ContractInfo } from "@/services/contract/agents/schemas/contract-info";
import { findEstimateMatch } from "./matcher";
import { storeMatchResult } from "./storage";
import type { MatchResult } from "./types";

/**
 * Result of the match processing step.
 */
export type MatchProcessResult =
  | { status: "matched"; estimateId: string; estimateName: string; confidence: number }
  | { status: "needs_selection"; candidateCount: number; topConfidence: number }
  | { status: "no_match"; reason: string }
  | { status: "missing_data"; reason: string };

/**
 * Process matching for a contract.
 * Gets extracted data, runs matching, stores result if auto-matched.
 */
export async function processContractMatch(
  contractId: number
): Promise<MatchProcessResult> {
  // Get extracted data from Phase 3
  const extracted = getAllExtractedData(contractId);
  if (!extracted) {
    return {
      status: "missing_data",
      reason: "No extraction data found for contract",
    };
  }

  // Extract contractInfo fields (from contractInfo agent)
  // The generalContractor field was added in Plan 01
  const contractInfo = extracted.contractInfo as ContractInfo | undefined;
  if (!contractInfo) {
    return {
      status: "missing_data",
      reason: "No contractInfo extraction found",
    };
  }

  const { projectName, generalContractor } = contractInfo;
  if (!projectName || !generalContractor) {
    return {
      status: "missing_data",
      reason: `Missing required fields: ${!projectName ? "projectName" : ""} ${!generalContractor ? "generalContractor" : ""}`.trim(),
    };
  }

  // Run matching
  const matchResult: MatchResult = await findEstimateMatch(
    projectName,
    generalContractor
  );

  // Handle results
  if (matchResult.status === "auto_matched") {
    // Store the auto-match
    storeMatchResult(contractId, matchResult.estimate, "auto", null);

    return {
      status: "matched",
      estimateId: matchResult.estimate.itemId,
      estimateName: matchResult.estimate.itemName,
      confidence: matchResult.confidence,
    };
  }

  if (matchResult.status === "needs_selection") {
    // Log candidates for human selection
    // Don't store yet - human needs to choose
    return {
      status: "needs_selection",
      candidateCount: matchResult.candidates.length,
      topConfidence: matchResult.topConfidence,
    };
  }

  // No match found
  return {
    status: "no_match",
    reason: matchResult.reason,
  };
}

/**
 * Manually select an estimate for a contract.
 * Called when human selects from candidates.
 */
export function selectEstimateMatch(
  contractId: number,
  estimateItemId: string,
  estimateItemName: string,
  confidence: number,
  matchedBy: string
): void {
  storeMatchResult(
    contractId,
    {
      itemId: estimateItemId,
      itemName: estimateItemName,
      itemUrl: `https://monday.com/boards/7943937851/pulses/${estimateItemId}`,
      projectScore: confidence, // Use combined as approximation
      contractorScore: confidence,
      combinedScore: confidence,
      estimateContractor: null,
    },
    "manual",
    matchedBy
  );
}

/**
 * Format match candidates for display.
 * Returns a formatted string showing top candidates with scores.
 */
export function formatCandidatesForSelection(
  candidates: Array<{
    itemId: string;
    itemName: string;
    itemUrl: string;
    combinedScore: number;
    projectScore: number;
    contractorScore: number;
    estimateContractor: string | null;
  }>
): string {
  return candidates
    .map((c, i) => {
      const confidence = Math.round(c.combinedScore * 100);
      const projectPct = Math.round(c.projectScore * 100);
      const contractorPct = Math.round(c.contractorScore * 100);
      const contractorInfo = c.estimateContractor
        ? `Contractor: ${c.estimateContractor} (${contractorPct}% match)`
        : "No contractor data";

      return [
        `${i + 1}. ${c.itemName} (${confidence}% confidence)`,
        `   Project similarity: ${projectPct}%`,
        `   ${contractorInfo}`,
        `   ID: ${c.itemId}`,
        `   URL: ${c.itemUrl}`,
      ].join("\n");
    })
    .join("\n\n");
}
```

This module:
- Gets extracted contract data from Phase 3 (uses generalContractor field added in Plan 01)
- Runs the matcher
- Stores auto-matches automatically
- Provides helpers for manual selection workflow
- Formats candidates for human review
  </action>
  <verify>
    `bun x tsc --noEmit services/contract/matching/link.ts` compiles without errors
    `bunx ultracite check services/contract/matching/link.ts` passes
  </verify>
  <done>
    - link.ts exports processContractMatch, selectEstimateMatch, formatCandidatesForSelection
    - Integrates with extraction storage and matcher
    - Auto-matches are stored immediately
    - No type or lint errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate matching into pipeline</name>
  <files>
    services/contract/pipeline/index.ts
  </files>
  <action>
Update the pipeline to run matching after Claude extraction completes.

**Modify services/contract/pipeline/index.ts:**

1. Add import at the top (after other imports):
```typescript
import { processContractMatch } from "../matching/link";
```

2. Add a new function `runEstimateMatching` after `runClaudeExtraction`:
```typescript
/**
 * Run estimate matching for a contract.
 * Matches the contract to Monday ESTIMATING board items.
 */
async function runEstimateMatching(contractId: number): Promise<void> {
  console.log(`[Pipeline] Starting estimate matching for contract ${contractId}...`);

  try {
    const result = await processContractMatch(contractId);

    switch (result.status) {
      case "matched":
        console.log(
          `[Pipeline] Auto-matched to estimate "${result.estimateName}" ` +
            `(${Math.round(result.confidence * 100)}% confidence)`
        );
        console.log(`[Pipeline] Estimate ID: ${result.estimateId}`);
        break;

      case "needs_selection":
        console.log(
          `[Pipeline] Match needs human selection - ${result.candidateCount} candidates, ` +
            `top confidence: ${Math.round(result.topConfidence * 100)}%`
        );
        console.log(`[Pipeline] Run /contract-match ${contractId} to select manually`);
        break;

      case "no_match":
        console.log(`[Pipeline] No matching estimate found: ${result.reason}`);
        break;

      case "missing_data":
        console.log(`[Pipeline] Cannot match - ${result.reason}`);
        break;
    }
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    console.error(`[Pipeline] Estimate matching failed: ${message}`);
    // Don't rethrow - matching failure shouldn't crash pipeline
  }
}
```

3. Update the `processContract` function to call matching after extraction. Add after the Claude extraction try/catch block (around line 120):
```typescript
    // Run estimate matching
    console.log(`[Pipeline] Starting estimate matching for contract ${contractId}...`);
    try {
      await runEstimateMatching(contractId);
    } catch {
      // Log but don't fail - extraction succeeded
      console.error(
        `[Pipeline] Estimate matching failed, can retry with /contract-match ${contractId}`
      );
    }
```

The pipeline flow becomes:
1. Mark as processing
2. Extract text (critical path)
3. Run Claude extraction (valuable but not blocking)
4. Run estimate matching (valuable but not blocking)
5. Mark as completed
  </action>
  <verify>
    `bun x tsc --noEmit services/contract/pipeline/index.ts` compiles without errors
    `bunx ultracite check services/contract/pipeline/index.ts` passes
  </verify>
  <done>
    - Pipeline imports matching module
    - runEstimateMatching function added
    - processContract calls matching after extraction
    - Match failures logged but don't crash pipeline
    - Logs indicate next steps for manual matching
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
    Complete estimate matching integration:
    1. Updated contractInfo schema with generalContractor field (Plan 01)
    2. Matching module with multi-field scoring (Plan 01)
    3. Link module that processes matches and stores results
    4. Pipeline integration that auto-runs matching after extraction
  </what-built>
  <how-to-verify>
    Test the full matching flow with a real contract:

    1. Start the pipeline:
       ```bash
       bun run services/contract/pipeline/index.ts
       ```

    2. Drop a contract PDF into the watch folder:
       ```bash
       cp /path/to/test-contract.pdf ./contracts/
       ```

    3. Watch the logs for:
       - "Starting estimate matching for contract N..."
       - One of: "Auto-matched to estimate", "Match needs human selection", or "No matching estimate found"

    4. Verify match was stored (if auto-matched):
       ```bash
       bun -e "import { getMatchForContract } from './services/contract/matching/storage'; console.log(getMatchForContract(1))"
       ```

    5. Test manual matching (if candidates shown):
       - Note the contract ID from logs
       - Run `/contract-match {contractId}` skill to see candidates and select

    Expected results:
    - Pipeline completes without crashing
    - Match result is appropriate for the contract data
    - High-confidence matches are stored automatically
    - Low-confidence matches show candidate list
  </how-to-verify>
  <resume-signal>Type "approved" if matching works correctly, or describe any issues found</resume-signal>
</task>

</tasks>

<verification>
After all tasks complete:
1. `bunx ultracite check services/contract/matching/ services/contract/pipeline/` - No lint errors
2. `bun x tsc --noEmit services/contract/matching/*.ts services/contract/pipeline/index.ts` - No type errors
3. Pipeline runs matching after extraction
4. Human verification confirms matching works end-to-end
</verification>

<success_criteria>
- Pipeline automatically runs matching after extraction
- Auto-matched contracts (>0.8 confidence) stored in SQLite
- Low-confidence matches log candidates and suggest manual selection
- Match failures don't crash the pipeline
- Human verification confirms end-to-end flow works
</success_criteria>

<output>
After completion, create `.planning/phases/04-estimate-matching/04-02-SUMMARY.md`
</output>
